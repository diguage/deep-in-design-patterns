<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="description" content="深入理解设计模式。">
<meta name="keywords" content="设计模式, Design Pattern">
<meta name="author" content="D瓜哥">
<title>深入学习设计模式 Alpha</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/styles/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
<script>var _hmt = _hmt || [];(function () {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?ae79ae5854e141fa6c9a217b5dcf0e45";var s = document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm, s);})();</script></head>
<body id="design-principles" class="book toc2 toc-left">
<div id="header">
<h1>深入学习设计模式 <sup>Alpha</sup></h1>
<div class="details">
<span id="author" class="author">D瓜哥</span><br>
<span id="email" class="email"><a href="https://www.diguage.com/" class="bare">https://www.diguage.com/</a></span><br>
<span id="revdate">2022-07-31</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<p><span class="toc-root"><a href="index.html">深入学习设计模式 <sup>Alpha</sup></a></span></p><ul class="sectlevel1">
<li><a href="_前言.html">前言</a>
</li>
<li><a href="object-oriented-programming.html">1. 面向对象程序设计</a>
</li>
<li><a href="design-principles.html"><span class="toc-current">2. 设计模式设计原则</span></a>
<ul class="sectlevel2">
<li><a href="design-principles.html#composite-aggregate-reuse-principle">2.1. 合成/聚合复用原则</a>
</li>
<li><a href="design-principles.html#dependence-inversion-principle">2.2. 依赖倒置原则</a>
</li>
<li><a href="design-principles.html#liskov-substitution-principle">2.3. 里氏代换原则</a>
</li>
<li><a href="design-principles.html#open-closed-principle">2.4. 开放-封闭原则</a>
</li>
<li><a href="design-principles.html#single-responsibility-principle">2.5. 单一职责原则</a>
</li>
<li><a href="design-principles.html#law-of-demeter">2.6. 迪米特法则</a>
</li>
</ul>
</li>
<li><a href="singleton.html">3. 单例模式</a>
</li>
<li><a href="proxy.html">4. 代理模式 与 AOP</a>
</li>
<li><a href="abstract-factory.html">5. 抽象工厂模式</a>
</li>
<li><a href="adapter.html">6. 适配器模式</a>
</li>
<li><a href="bridge.html">7. 桥接模式</a>
</li>
<li><a href="builder.html">8. 建造者模式</a>
</li>
<li><a href="chain-of-responsibility.html">9. 职责链模式</a>
</li>
<li><a href="command.html">10. 命令模式</a>
</li>
<li><a href="composite.html">11. 组合模式</a>
</li>
<li><a href="decorator.html">12. 装饰器模式</a>
</li>
<li><a href="facade.html">13. 外观模式</a>
</li>
<li><a href="factory-method.html">14. 工厂方法模式</a>
</li>
<li><a href="flyweight.html">15. 享元模式</a>
</li>
<li><a href="interpreter.html">16. 解释器模式</a>
</li>
<li><a href="iterator.html">17. 迭代器模式</a>
</li>
<li><a href="mediator.html">18. 中介者模式</a>
</li>
<li><a href="memento.html">19. 备忘录模式</a>
</li>
<li><a href="observer.html">20. 观察者模式</a>
</li>
<li><a href="prototype.html">21. 原型模式</a>
</li>
<li><a href="state.html">22. 状态模式</a>
</li>
<li><a href="strategy.html">23. 策略模式</a>
</li>
<li><a href="template-method.html">24. 模版方法模式</a>
</li>
<li><a href="visitor.html">25. 访问者模式</a>
</li>
<li><a href="summary.html">26. 总结</a>
</li>
<li><a href="references.html">附录 D: 参考资料</a>
</li>
<li><a href="plant-uml.html">附录 E: Plant UML 类图小技巧</a>
</li>
<li><a href="license.html">附录 F: 版权声明</a>
</li>
</ul>
</div>
</div>
<div id="content"><div class="sect2"><h3 id="_友情支持">友情支持</h3><div class="paragraph"><p>如果您觉得这个笔记对您有所帮助，看在D瓜哥码这么多字的辛苦上，请友情支持一下，D瓜哥感激不尽，😜</p></div><table class="tableblock frame-none grid-all stretch"><colgroup><col style="width: 50%;"><col style="width: 50%;"></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><span class="image"><img src="assets/images/alipay.png" alt="支付宝" width="85%" title="支付宝"></span></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><span class="image"><img src="assets/images/wxpay.jpg" alt="微信" width="85%" title="微信"></span></p></td></tr></tbody></table><div class="paragraph"><p>有些打赏的朋友希望可以加个好友，欢迎关注D 瓜哥的微信公众号，这样就可以通过公众号的回复直接给我发信息。</p></div><div class="paragraph"><p><span class="image"><img src="assets/images/wx-jikerizhi.png" alt="wx jikerizhi" width="98%"></span></p></div><div class="admonitionblock tip"><table><tbody><tr><td class="icon"><i class="fa icon-tip" title="Tip"></i></td><td class="content"><strong>公众号的微信号是: <code>jikerizhi</code></strong>。<em>因为众所周知的原因，有时图片加载不出来。 如果图片加载不出来可以直接通过搜索微信号来查找我的公众号。</em></td></tr></tbody></table></div></div>
<div class="sect1">
<h2 id="design-principles"><a class="anchor" href="#design-principles"></a>2. 设计模式设计原则</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="composite-aggregate-reuse-principle"><a class="anchor" href="#composite-aggregate-reuse-principle"></a>2.1. 合成/聚合复用原则</h3>
<div class="paragraph">
<p>刚开始学会用面向对象的继承时，感觉它既新颖又功能强大，所以只要可以用，就都用上继承。这就好比是‘有了新锤子，所有的东西看上去都成了钉子。[DPE]</p>
</div>
<div class="paragraph">
<p>事实上，很多情况用继承会带来麻烦。</p>
</div>
<div class="paragraph">
<p>对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性[DP]。</p>
</div>
<div class="paragraph">
<p>在面向对象设计中，我们还有一个很重要的设计原则，那就是合成/聚合复用原则。即优先使用对象合成/聚合，而不是类继承[DP]。</p>
</div>
<div class="paragraph">
<p>合成（Composition，也有翻译成组合）和聚合（Aggregation）都是关联的特殊种类。聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样[DPE]。</p>
</div>
<div class="paragraph">
<p>合成/聚合复用原则的好处是，优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物[DP]。</p>
</div>
<div class="paragraph">
<p>开放-封闭原则。这样的设计显然不会修改原来的代码，而只是扩展类就行了。但今天我的感受最深的是合成/聚合复用原则，也就是优先使用对象的合成或聚合，而不是类继承。聚合的魅力无限呀。相比，继承的确很容易造成不必要的麻烦。</p>
</div>
<div class="paragraph">
<p>盲目使用继承当然就会造成麻烦，而其本质原因主要是什么？”
“我想应该是，继承是一种强耦合的结构。父类变，子类就必须要变。</p>
</div>
<div class="paragraph">
<p>在用继承时，一定要在是‘is-a’的关系时再考虑使用，而不是任何时候都去使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="dependence-inversion-principle"><a class="anchor" href="#dependence-inversion-principle"></a>2.2. 依赖倒置原则</h3>
<div class="paragraph">
<p>CPU的对外都是针脚式或触点式等标准的接口。啊，我明白了，这就是接口的最大好处。CPU只需要把接口定义好，内部再复杂我也不让外界知道，而主板只需要预留与CPU针脚的插槽就可以了。</p>
</div>
<div class="paragraph">
<p>比如我们之前讲过的单一职责原则，就刚才修电脑的事，显然内存坏了，不应该成为更换CPU的理由，它们各自的职责是明确的。再比如开放-封闭原则，内存不够只要插槽足够就可以添加，硬盘不够可以用移动硬盘等，PC的接口是有限的，所以扩展有限，软件系统设计得好，却可以无限地扩展。</p>
</div>
<div class="paragraph">
<p>依赖倒转原则，也有翻译成依赖倒置原则的。</p>
</div>
<div class="paragraph">
<p>依赖倒转原则，原话解释是抽象不应该依赖细节，细节应该依赖于抽象，这话绕口，说白了，就是要针对接口编程，不要对实现编程，无论主板、CPU、内存、硬盘都是在针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬。</p>
</div>
<div class="paragraph">
<p>面向过程的开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们在做新项目时，去调用这些低层的函数就可以了。</p>
</div>
<div class="paragraph">
<p>这也就叫做高层模块依赖低层模块。</p>
</div>
</div>
<div class="sect2">
<h3 id="liskov-substitution-principle"><a class="anchor" href="#liskov-substitution-principle"></a>2.3. 里氏代换原则</h3>
<div class="quoteblock">
<blockquote>
<div class="dlist">
<dl>
<dt class="hdlist1">里氏代换原则（LSP）</dt>
<dd>
<p>子类型必须能够替换掉它们的父类型。</p>
</dd>
</dl>
</div>
</blockquote>
<div class="attribution">
&#8212; Robert C. Martin<br>
<cite>《敏捷软件开发：原则、模式与实践》</cite>
</div>
</div>
<div class="paragraph">
<p>里氏代换原则是Barbara Liskov女士在1988年发表的[ASD]</p>
</div>
<div class="paragraph">
<p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型[ASD]。</p>
</div>
<div class="paragraph">
<p>也正因为有了这个原则，使得继承复用成为了可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。</p>
</div>
<div class="paragraph">
<p>由于有里氏代换原则，才使得开放-封闭成为了可能。</p>
</div>
<div class="paragraph">
<p>由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。</p>
</div>
<div class="paragraph">
<p>依赖倒转其实就是谁也不要依靠谁，除了约定的接口，大家都可以灵活自如。</p>
</div>
<div class="paragraph">
<p>依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了[ASD]。</p>
</div>
</div>
<div class="sect2">
<h3 id="open-closed-principle"><a class="anchor" href="#open-closed-principle"></a>2.4. 开放-封闭原则</h3>
<div class="quoteblock">
<blockquote>
<div class="dlist">
<dl>
<dt class="hdlist1">开放-封闭原则</dt>
<dd>
<p>软件实体（类、模块、函数等等）应该可以扩展，但是不可以修改。</p>
</dd>
</dl>
</div>
</blockquote>
<div class="attribution">
&#8212; Robert C. Martin<br>
<cite>《敏捷软件开发：原则、模式与实践》</cite>
</div>
</div>
<div class="paragraph">
<p>在软件设计模式中，这种不能修改，但可以扩展的思想也是最重要的一种设计原则，它就是开放-封闭原则（The Open-Closeed Principle，简称OCP）或叫开-闭原则。</p>
</div>
<div class="paragraph">
<p>对于扩展是开放的（Open for extension）</p>
</div>
<div class="paragraph">
<p>对于更改是封闭的（Closed for modification）’[ASD]。</p>
</div>
<div class="paragraph">
<p>怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本呢？[ASD]，开放-封闭给我们答案。</p>
</div>
<div class="paragraph">
<p>开放-封闭原则的意思就是说，你设计的时候，时刻要考虑，尽量让这个类是足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。</p>
</div>
<div class="paragraph">
<p>无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化[ASD]。</p>
</div>
<div class="paragraph">
<p>我们是很难预先猜测，但我们却可以在发生小变化时，就及早去想办法应对发生更大变化的可能。也就是说，等到变化发生时立即采取行动[ASD]。正所谓，同一地方，摔第一跤不是你的错，再次在此摔跤就是你的不对了。</p>
</div>
<div class="paragraph">
<p>在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化[ASD]。</p>
</div>
<div class="paragraph">
<p>面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码[ASD]。这就是‘开放-封闭原则’的精神所在。</p>
</div>
<div class="paragraph">
<p>我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难[ASD]。</p>
</div>
<div class="paragraph">
<p>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要[ASD]</p>
</div>
</div>
<div class="sect2">
<h3 id="single-responsibility-principle"><a class="anchor" href="#single-responsibility-principle"></a>2.5. 单一职责原则</h3>
<div class="quoteblock">
<blockquote>
<div class="dlist">
<dl>
<dt class="hdlist1">单一职责原则（SRP）</dt>
<dd>
<p>就一个类而言，应该仅有一个引起它变化的原因</p>
</dd>
</dl>
</div>
</blockquote>
<div class="attribution">
&#8212; Robert C. Martin<br>
<cite>《敏捷软件开发：原则、模式与实践》</cite>
</div>
</div>
<div class="paragraph">
<p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏[ASD]。</p>
</div>
<div class="paragraph">
<p>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离[ASD]。其实要去判断是否应该分离出类来，也不难，那就是如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责[ASD]，就应该考虑类的职责分离。”</p>
</div>
<div class="paragraph">
<p>编程时，我们却是要在类的职责分离上多思考，做到单一职责，这样你的代码才是真正的易维护、易扩展、易复用、灵活多样。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.jianshu.com/p/f9d15827465d">面向对象设计-单一职责原则(SRP) - 简书</a></p>
</li>
<li>
<p><a href="http://studyai.site/2015/09/06/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/">设计模式六大原则之 单一职责原则 | DannyLee</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="law-of-demeter"><a class="anchor" href="#law-of-demeter"></a>2.6. 迪米特法则</h3>
<div class="quoteblock">
<blockquote>
<div class="dlist">
<dl>
<dt class="hdlist1">迪米特法则（Law of Demeter）</dt>
<dd>
<p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>
</dd>
</dl>
</div>
</blockquote>
<div class="attribution">
&#8212; 阎宏<br>
<cite>Java 与模式</cite>
</div>
</div>
<div class="paragraph">
<p>‘迪米特法则（LoD）’也叫最少知识原则。[J&amp;DP]</p>
</div>
<div class="paragraph">
<p>迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限[J&amp;DP]，也就是说，一个类包装好自己的private状态，不需要让别的类知道的字段或行为就不要公开。</p>
</div>
<div class="paragraph">
<p>迪米特法则其根本思想，是强调了类之间的松耦合。</p>
</div>
<div class="paragraph">
<p>类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。也就是说，信息的隐藏促进了软件的复用。</p>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="object-oriented-programming.html">面向对象程序设计</a> | ↑ Up: <a href="index.html">深入学习设计模式 &lt;sup&gt;Alpha&lt;/sup</a>&gt; | Next: <a href="singleton.html">单例模式</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
最后更新时间 2022-07-31 10:08:33 UTC
</div>
</div>
</body>
</html>