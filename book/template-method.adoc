[[template-method]]
== 模版方法模式

plantuml::./puml/template-method.puml[target={puml_target_dir}/template-method,{puml_attr}]

当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。

AbstractClass是抽象类，其实也就是一抽象模板，定义并实现了一个模版方法。这个模版方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。

ConcreteClass，实现父类所定义的一个或多个抽象方法。每一个AbstractClass都可以有任意多个ConcreteClass与之对应，而每一个ConcreteClass都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。

模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。

模板方法模式就是提供了一个很好的代码复用平台。

因为有时候，我们会遇到由一系列步骤构成的过程需要执行。这个过程从高层次上看是相同的，但有些步骤的实现可能不同。这时候，我们通常就应该要考虑用模板方法模式了。

当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。

[source,{java_source_attr}]
.AbstractClass 类
----
include::{source_dir}/template-method/AbstractClass.java[]
----



[source,{java_source_attr}]
.ConcreteClass 类
----
include::{source_dir}/template-method/ConcreteClass.java[]
----


