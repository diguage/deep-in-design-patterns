[[object-oriented-programming]]
== 面向对象程序设计

GoF的《设计模式》好比是世界顶级足球射门集锦，《重构》、《敏捷软件开发》、《设计模式解析》好比是一场场最精彩的足球比赛。

他们尽管有一定天分，但却也是从最底层通过努力一点一点慢慢显露出来的，我们需要的不仅仅是世界杯上的那定乾坤的一脚，更需要这一脚之前是如何练出那种神奇的方法，对于程序员来讲，精彩的代码是如何想出来的，要比看到精彩的代码更加令人期待。

《重构与模式》中有一句经典之语：“如果想成为一名更优秀的软件设计师，了解优秀软件设计的演变过程比学习优秀设计本身更有价值，因为设计的演变过程中蕴藏着大智慧。”

通过这些模式让你找到“封装变化”、“对象间松散耦合”、“针对接口编程”的感觉，从而设计出易维护、易扩展、易复用、灵活性好的程序。

如果说，数学是思维的体操，那设计模式，就是面向对象编程思维的体操。

“话说三国时期，曹操带领百万大军攻打东吴，大军在长江赤壁驻扎，军船连成一片，眼看就要灭掉东吴，统一天下，曹操大悦，于是大宴众文武，在酒席间，曹操诗性大发，不觉吟道：‘喝酒唱歌，人生真爽。……’。众文武齐呼：‘丞相好诗！’于是一臣子速命印刷工匠刻版印刷，以便流传天下。” “样张出来给曹操一看，曹操感觉不妥，说道：‘喝与唱，此话过俗，应改为‘对酒当歌’较好！’，于是此臣就命工匠重新来过。工匠眼看连夜刻版之工，彻底白费，心中叫苦不迭。只得照办。” “样张再次出来请曹操过目，曹操细细一品，觉得还是不好，说：‘人生真爽太过直接，应改问语才够意境，因此应改为‘对酒当歌，人生几何？……’当臣转告工匠之时，工匠晕倒……！”

第一，要改，只需更改要改之字，此为可维护；第二，这些字并非用完这次就无用，完全可以在后来的印刷中重复使用，此乃可复用；第三，此诗若要加字，只需另刻字加入即可，这是可扩展；第四，字的排列其实可能是竖排可能是横排，此时只需将活字移动就可做到满足排列需求，此是灵活性好。

通过封装、继承、多态把程序的耦合度降低

用设计模式使得程序更加的灵活，容易修改，并且易于复用。

中国古代的四大发明，另三种应该都是科技的进步，伟大的创造或发现。而唯有活字印刷，实在是思想的成功，面向对象的胜利。

聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分[DPE]（DPE表示此句摘自《设计模式》（第2版），详细摘要说明见附录二）。聚合关系用空心的菱形+实线箭头来表示。”

合成（Composition，也有翻译成‘组合’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样[DPE]。在这里鸟和其翅膀就是合成（组合）关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。合成关系用实心的菱形+实线箭头来表示。

编程是一门技术，更加是一门艺术，不能只满足于写完代码运行结果正确就完事，时常考虑如何让代码更加简练，更加容易维护，容易扩展和复用，只有这样才可以真正得到提高。

// 附录

面向过程关注业务流程，但无论多么努力工作，分析做得如何好，也是永远无法从用户那里获得所有的需求的，而业务流程却是需求中最可能变化的地方，业务流程的制定需要受到很多条件的限制，甚至程序的效率、运行方式都会反过来影响业务流程。有时候用户也会为了更好地实现商业目的，主动地改变业务流程，并且一个流程的变化经常会带来一系列的变化。这就使得按照业务流程设计的程序经常面临变化。

流程的易变性，使得把流程看得很重，并不能适应变化。

面向过程通过划分功能模块，通过函数相互间的调用来实现，但需求变化时，就需要更改函数。而你改动的函数有多少的地方在调用它，关联多少数据，这是很不容易弄得清楚的地方。

与其抱怨需求总是变化，不如改变开发过程，从而更有效地应对变化。面向对象的编程方式诞生，就是为解决变化带来的问题。

面向对象关注的是对象，对象的优点在于，可以定义自己负责的事物，做要求它自己做的事情。对象应该自己负责自己，而且应该清楚地定义责任。

需求变化是必然的，那么尽管无法预测会发生什么变化，但是通常可以预测哪里会发生变化。面向对象的优点之一，就是可以封装这些变化区域，从而更容易地将代码与变化产生的影响隔离开来。代码可以设计得使需求的变化不至于产生太大的影响。代码可以逐步演进，新代码可以影响较少地加入。

设计模式是面向对象技术的最新进展之一。由于面向对象设计的复杂性，所以我们都希望能做出应对变化，提高复用的设计方案，而设计模式就能帮助我们做到这样的结果。通过复用已经公认的设计，我们能够在解决问题时避免前人所犯的种种错误，可以从学习他人的经验中获益，用不着为那些总是会重复出现的问题再次设计解决方案。显然，设计模式有助于提高我们的思考层次。让我们能站在山顶而不是山脚，也就是更高的高度来俯视我们的设计。

抽象工厂小姐，她的口号是提供一个创建一系列或相关依赖对象的接口，而无需指定它们具体的类。[DP]

建造者小姐，她的口号是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。[DP]

工厂方法小姐向我们走来，她声称定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到其子类。[DP]

原型小姐，她的意图是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。[DP]

单例小姐，她提倡简捷就是美，保证一个类仅有一个实例，并提供一个访问它的全局访问点。[DP]

创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性[DP]。

当一个系统应该独立于它的产品创建、构成和表示时，应该考虑用创建性模式。建立相应数目的原型并克隆它们通常比每次用合适的状态手工实例化该类更方便一些[DP]。

内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。而耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目标应该是创建这样的例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合[DPE]。

将一个复杂对象的构建与它的表示分离，这就可以很容易地改变一个产品的内部表示，并且使得构造代码和表示代码分开。这样对于客户来说，它无需关心产品的创建过程，而只要告诉我需要什么，我就能用同样的构建过程创建不同的产品给客户[DP]。

对一些类来说，一个实例是很重要的。一个全局变量可以使得一个对象被访问，但它不能防止客户实例化多个对象。我的优势就是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且我还提供了一个访问该实例的方法。这样就使得对唯一的实例可以严格地控制客户怎样以及何时访问它[DP]。

创建型模式抽象了实例化的过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定。[DP]

通常设计应该是从我，也就是工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地。[DP]

工厂方法能使得我们增加新的产品时，不需要去更改原有的产品体系和工厂类，只需扩展新的类就可以了。

适配器小姐，她的口号是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。[DP]

桥接。桥接小姐提倡的是将抽象部分与它的实现部分分离，使它们都可以独立地变化。[DP]

组合小姐，一个非常美丽的姑娘，她的口号是将对象组合成树形结构以表示‘部分-整体’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。[DP]

装饰小姐，她的意图非常简单，就是动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活[DP]。

外观小姐，她的形象如她的名字一样的棒，她说为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。[DP]

享元小姐，她的参赛宣言为运用共享技术有效地支持大量细粒度的对象。[DP]

代理小姐向我们走来，她声称为其他对象提供一种代理以控制对这个对象的访问。[DP]

面向对象的精神就是更好地应对需求的变化，而现实中往往会有下面这些情况，想使用一个已经存在的类，而它的接口不符合要求，或者希望创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。

让这些接口不同的类通过适配后，协同工作。[DP]

继承是好的东西，但往往会过度地使用，继承会导致类的结构过于复杂，关系太多，难以维护，而更糟糕的是扩展性非常差。而仔细研究如果能发现继承体系中，有两个甚至多个方向的变化，那么就解耦这些不同方向的变化，通过对象组合的方式，把两个角色之间的继承关系改为了组合的关系，从而使这两者可以应对各自独立的变化，事实上也就是合成聚合复用女士所提倡的原则，总之，面对变化，我主张‘找出变化并封装之’。[DPE]

面对变化，如果采用生成子类的方法进行扩充，为支持每一种扩展的组合，会产生大量的子类，使得子类数目呈爆炸性增长。这也是刚才桥接小姐所提到的继承所带来的灾难，而事实上，这些子类多半只是为某个对象增加一些职责，此时通过装饰的方式，可以更加灵活、以动态、透明的方式给单个对象添加职责，并在不需要时，撤销相应的职责。[DP]

希望用户忽略组合对象与单个对象的不同，用户将可以统一地使用组合结构中的所有对象。

用户使用组合类接口与组合结构中的对象进行交互，如果接收者是一个叶节点，则直接处理请求，如果接收者是组合对象，通常将请求发送给它的子部件，并在转发请求之前或之后可能执行一些辅助操作。组合模式的效果是客户可以一致地使用组合结构和单个对象。任何用到基本对象的地方都可以使用组合对象。[DP]

外观小姐，信息的隐藏促进了软件的复用[J&DP]

类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。如果两个类不必彼此直接通信，那么就不要让这两个类发生直接的相互作用。如果实在需要调用，可以通过第三者来转发调用。[J&DP]

应该让一个软件中的子系统间的通信和相互依赖关系达到最小，而具体办法就是引入一个外观对象，它为子系统间提供了一个单一而简单的屏障[DP]。

通常企业软件的三层或N层架构，层与层之间地分离其实就是外观模式的体现。

对象使得内存占用过多，而且如果都是大量重复的对象，那就是资源的极大浪费[DP]

面向对象技术有时会因简单化的设计而代价极大。

代理与外观的主要区别在于，代理对象代表一个单一对象而外观对象代表一个子系统；代理的客户对象无法直接访问目标对象，由代理提供对单独的目标对象的访问控制，而外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象提供对子系统各元件功能的简化的共同层次的调用接口。[R2P]

代理是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代表交涉。而适配器则不需要虚构出一个代表者，只需要为应付特定使用目的，将原来的类进行一些组合。[DP]

适配器说：“我主要是为了解决两个已有接口之间不匹配的问题，我不需要考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化。我的这种方式不需要对两个独立设计的类中任一个进行重新设计，就能够使它们协同工作。[DP]

我觉得我和适配器小姐具有一些共同的特征，就是给另一对象提供一定程度的间接性，这样可以有利于系统的灵活性。但正所谓未雨绸缪，我们不能等到问题发生了，再去考虑解决问题，而是更应该在设计之初就想好应该如何做来避免问题的发生，我通常是在设计之初，就对抽象接口与它的实现部分进行桥接，让抽象与实现两者可以独立演化。显然，我的优势更明显。[DP]

桥接和适配器是被用于软件生命周期的不同阶段，针对的是不同的问题，谈不上孰优孰劣。

然后，对于我来说，和适配器还有些近似，都是对现存系统的封装，有人说我其实就是另外一组对象的适配器，这种说法是不准确的，因为外观定义的是一个新的接口，而适配器则是复用一个原有的接口，适配器是使两个已有的接口协同工作，而外观则是为现存系统提供一个更为方便的访问接口。如果硬要说我是适配，那么适配器是用来适配对象的，而我则是用来适配整个子系统的。也就是说，我所针对的对象的粒度更大。[DP]

观察者小姐入场，它的口号是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。[DP]

模板方法小姐，她提倡定义一个操作的算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。[DP]

命令小姐，它觉得应该将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；可以对请求排队或记录请求日志，以及支持可撤销的操作。[DP]

状态小姐，她说允许一个对象在其内部状态改变时改变它的行为，让对象看起来似乎修改了它的类。[DP]

职责链小姐，她一直认为使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。[DP]

对象间，尤其是具体对象间，相互知道的越少越好，这样发生改变时才不至于互相影响。对于我来说，目标和观察者不是紧密耦合的，它们可以属于一个系统中的不同抽象层次，目标所知道的仅仅是它有一系列的观察者，每个观察者实现Observer的简单接口，观察者属于哪一个具体类，目标是不知道的。

代码重复是编程中最常见、最糟糕的‘坏味道’，如果我们在一个以上的地方看到相同的程序结构，那么可以肯定，设法将它们合而为一，程序会变得更好[RIDEC]。但是完全相同的代码当然存在明显的重复，而微妙的重复会出现在表面不同但是本质相同的结构或处理步骤中[R2P]，这使得我们一定要小心处理。继承的一个非常大的好处就是你能免费地从基类获取一些东西，当你继承一个类时，派生类马上就可以获得基类中所有的功能，你还可以在它的基础上任意增加新的功能。模板方法模式由一个抽象类组成，这个抽象类定义了需要覆盖的可能有不同实现的模板方法，每个从这个抽象类派生的具体类将为此模板实现新方法[DPE]。这样就使得，所有可重复的代码都提炼到抽象类中了，这就实现了代码的重用。

将调用操作的对象与知道如何实现该操作的对象解耦

在不同的时刻指定、排列和执行请求。

支持取消/重做的操作。我还可以记录整个操作的日志

支持事务

有多个对象可以处理一个请求，哪个对象处理该请求事先并不知道，要在运行时刻自动确定，此时，最好的办法就是让请求发送者与具体处理者分离，让客户在不明确指定接收者的情况下，提交一个请求，然后由所有能处理这请求的对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。”职责链

状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不在单块的if或switch中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于某个状态子类中，所以通过定义新的子类可以很容易地增加新的状态和转换。[DP]

MVC是包括三类对象，Model是应用对象，View是它在屏幕上的表示，Controller定义用户界面对用户输入的响应方式。如果不使用MVC，则用户界面设计往往将这些对象混在一起，而MVC则将它们分离以提高灵活性和复用性[DP]。

MVC是多种模式的综合应用，应该算是一种架构模式

解释器小姐，它声称给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。[DP]

中介者小姐，她说她是用一个中介对象来封装一系列的对象交互。中介者使各对像不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。[DP]

访问者小姐，她表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。[DP]

策略，一个可爱的姑娘，她的意图是定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。[DP]

备忘录小姐，她说在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。[DP]

迭代器小姐，她说，提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。[DP]

如果一种特定类型的问题发生的频率足够高，那么就可以考虑将该问题的各个实例表述为一个简单语言中的句子。也就是说，通过构建一个解释器，该解释器解释这些句子来解决该问题[DP]。

比如正则表达式就是描述字符串模式的一种标准语言，与其为每一个字符串模式都构造一个特定的算法，不如使用一种通用的搜索算法来解释执行一个正则表达式，该正则表达式定义了待匹配字符器的集合[DP]。

面向对象设计鼓励将行为分布到各个对象中，这种分布可能会导致对象间有许多连接。也就是说，有可能每一个对象都需要知道其他许多对象。对象间的大量相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作，这对于应对变化是不利的，任何较大的改动都很困难[DP]。

将集体行为封装一个单独的中介者对象来避免这个问题，中介者负责控制和协调一组对象间的交互。中介者充当一个中介以使组中的对象不再相互显式引用。这些对象仅知道中介者，从而减少了相互连接的数目[DP]。

最少知识原则，也就是如何减少耦合的问题，类之间的耦合越弱，越有利于复用[J&DP]。

访问者增加具体的Element是困难的，但增加依赖于复杂对象结构的构件的操作就变得容易。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。

优先使用对象组合，而非类继承

继承提供了一种支持多种算法或行为的方法，我们可以直接生成一个类A的子类B、C、D，从而给它以不同的行为。但这样会将行为硬行编制到父类A当中，而将算法的实现与类A的实现混合起来，从而使得类A难以理解、难以维护和难以扩展，而且还不能动态地改变算法。仔细分析会发现，它们之间的唯一差别是它们所使用的算法或行为，将算法封装在独立的策略Strategy类中使得你可以独立于其类A改变它，使它易于切换、易于理解、易于扩展[DP]。

通常原对象A都有很多状态属性，保存对象的内部状态，其实也就是将这些状态属性的值可以记录到A对象外部的另一个对象B，但是，如果记录的过程是对外透明的，那就意味着保存过程耦合了对象状态细节。使用备忘录就不会出现这个问题，它可以避免暴露一些只应由对象A管理却又必须存储在对象A之外的信息。备忘录模式把可能很复杂的对象A的内部信息对其他对象屏蔽起来，从而保持了封装边界[DP]。

一个集合对象，它当中具体是些什么对象元素我并不知道，但不管如何，应该提供一种方法来让别人可以访问它的元素，而且可能要以不同的方式遍历这个集合。迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，迭代器类定义了一个访问该列表元素的接口。迭代器对象负责跟踪当前的元素，并且知道哪些元素已经遍历过了[DP]。

只要是在做面向对象的开发，创建对象的工作不可避免。创建对象时，负责创建的实体通常需要了解要创建的是哪个具体的对象，以及何时创建这个而非那个对象的规则。而我们如果希望遵循开放-封闭原则、依赖倒转原则和里氏代换原则，那使用对象时，就不应该知道所用的是哪一个特选的对象。此时就需要‘对象管理者’工厂来负责此事[DPE]。

在创建对象时，使用抽象工厂、原型、建造者的设计比使用工厂方法要更灵活，但它们也更加复杂，通常，设计是以使用工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化[DP]。

工厂方法的实现并不能减少工作量，但是它能够在必须处理新情况时，避免使已经很复杂的代码更加复杂[DPE]。

面向对象设计模式体现的就是抽象的思想，类是什么，类是对对象的抽象，抽象类呢，其实就是对类的抽象，那接口呢，说白了就是对行为的抽象。

对象是一个自包含的实体，用一组可识别的特性和行为来标识。面向对象编程，英文叫Object-Oriented Programming，其实就是针对对象来进行编程的意思。

类就是具有相同的属性和功能的对象的抽象的集合

第一，类名称首字母记着要大写。多个单词则各个首字母大写；第二，对外公开的方法需要用‘public’修饰符。

实例，就是一个真实的对象。

实例化就是创建对象的过程，使用new关键字来创建。

构造方法，又叫构造函数，其实就是对类进行初始化。构造方法与类同名，无返回值，也不需要void，在new时候调用。

所有类都有构造方法，如果你不编码则系统默认生成空的构造方法，若你有定义的构造方法，那么默认的构造方法就会失效了。

方法重载提供了创建同名的多个方法的能力，但这些方法需使用不同的参数类型。

方法重载时，两个方法必须要方法名相同，但参数类型或个数必须要有所不同，否则重载就没有意义了。

方法重载可在不改变原方法的基础上，新增功能。

属性是一个方法或一对方法，但在调用它的代码看来，它是一个字段，即属性适合于以字段的方式使用方法调用的场合。这里还需要解释一下字段的意思，字段是存储类要满足其设计所需要的数据，字段是与类相关的变量。

public表示它所修饰的类成员可以允许其他任何类来访问，俗称公有的。而private表示只允许同一个类中的成员访问，其他类包括它的子类无法访问，俗称私有的。

通常字段都是private，即私有的变量，而属性都是public，即公有的变量。

属性有两个方法get和set。get访问器返回与声明的属性相同的数据类型，表示的意思是调用时可以得到内部字段的值或引用；set访问器没有显式设置参数，但它有一个隐式参数，用关键字value表示，它的作用是调用属性时可以给内部的字段或引用赋值。

每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装，因此对象不必依赖其他对象来完成自己的操作。

封装有很多好处，第一、良好的封装能够减少耦合

第二、类内部的实现可以自由地修改

第三、类具有清晰的对外接口

对象的继承代表了一种‘is-a’的关系，如果两个对象A和B，可以描述为‘B是A’，则表明B可以继承A。

继承者还可以理解为是对被继承者的特殊化，因为它除了具备被继承者的特性外，还具备自己独有的个性。

继承定义了类如何相互关联，共享特性。继承的工作方式是，定义父类和子类，或叫做基类和派生类，其中子类继承父类的所有特性。子类不但继承了父类的所有特性，还可以定义新的特性。

如果子类继承于父类，第一、子类拥有父类非private的属性和功能；第二、子类具有自己的属性和功能，即子类可以扩展父类没有的属性和功能；第三、子类还可以以自己的方式实现父类的功能（方法重写）。

protected表示继承时子类可以对基类有完全访问权

子类从它的父类中继承的成员有方法、域、属性、事件、索引指示器，但对于构造方法，有一些特殊，它不能被继承，只能被调用。对于调用父类的成员，可以用base关键字。”

不用继承的话，如果要修改功能，就必须在所有重复的方法中修改，代码越多，出错的可能就越大，而继承的优点是，继承使得所有子类公共的部分都放在了父类，使得代码得到了共享，这就避免了重复，另外，继承可使得修改或扩展继承而来的实现都较为容易。

继承是有缺点的，那就是父类变，则子类不得不变。

继承会破坏包装，父类实现细节暴露给子类，这其实是增大了两个类之间的耦合性。

继承显然是一种类与类之间强耦合的关系。

当两个类之间具备‘is-a’的关系时，就可以考虑用继承

面向对象的第三大特性——多态。

多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行。

第一，子类以父类的身份出现，儿子代表老子表演，化妆后就是以父亲身份出现了。第二、子类在工作时以自己的方式来实现，儿子模仿得再好，那也是模仿，儿子只能用自己理解的表现方式去模仿父亲的作品；第三、子类以父类的身份出现时，子类特有的属性和方法不可以使用，儿子经过多年学习，其实已经有了自己的创作，自己的绝活，但在此时，代表父亲表演时，绝活是不能表现出来的。当然，如果父亲还有别的儿子会表演，也可以在此时代表父亲上场，道理也是一样的。这就是多态。

为了使子类的实例完全接替来自父类的类成员，父类必须将该成员声明为虚拟的。这是通过在该成员的返回类型之前添加virtual关键字来实现。

子类可以选择使用override关键字，将父类实现替换为它自己的实现，这就是方法重写Override，或者叫做方法覆写。

不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行。

对象的声明必须是父类，而不是子类，实例化的对象是子类，这才能实现多态。多态的原理是当方法被调用时，无论对象是否被转换为其父类，都只有位于对象继承链最末端的方法实现会被调用。也就是说，虚方法是按照其运行时类型而非编译时类型进行动态绑定调用的。[AMNFP]

没有学过设计模式，那么对多态、乃至对面向对象的理解多半都是肤浅和片面的。

C#允许把类和方法声明为abstract，即抽象类和抽象方法。

第一，抽象类不能实例化

第二，抽象方法是必须被子类重写的方法

第三，如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法。

考虑让抽象类拥有尽可能多的共同代码，拥有尽可能少的数据[J&DP]。

抽象类通常代表一个抽象概念，它提供一个继承的出发点，当设计一个新的抽象类时，一定是用来继承的，所以，在一个以继承关系形成的等级结构里面，树叶节点应当是具体类，而树枝节点均应当是抽象类[J&DP]。

接口是把隐式公共方法和属性组合起来，以封装特定功能的一个集合。一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的执行方式。

实现接口的类就必须要实现接口中的所有方法和属性。

一个类可以支持多个接口，多个类也可以支持相同的接口。

记住，接口的命名，前面要加一个大写字母‘I’，这是规范。

接口用interface声明，而不是class，接口名称前要加‘I’，接口中的方法或属性前面不能有修饰符、方法没有方法体。

抽象类可以给出一些成员的实现，接口却不包含成员的实现，抽象类的抽象成员可被子类部分实现，接口的成员需要实现类完全实现，一个类只能继承一个抽象类，但可实现多个接口等等。

第一，类是对对象的抽象；抽象类是对类的抽象；接口是对行为的抽象。接口是对类的局部（行为）进行的抽象，而抽象类是对类整体（字段、属性、方法）的抽象。如果只关注行为抽象，那么也可以认为接口就是抽象类。总之，不论是接口、抽象类、类甚至对象，都是在不同层次、不同角度进行抽象的结果，它们的共性就是抽象。第二，如果行为跨越不同类的对象，可使用接口；对于一些相似的类对象，用继承抽象类。

实现接口和继承抽象类并不冲突

第三，从设计角度讲，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口是根本不知子类的存在，方法如何实现还不确认，预先定义。

通过重构改善既有代码的设计。

抽象类往往都是通过重构得来的，当然，如果你事先意识到多种分类的可能，那么事先就设计出抽象类也是完全可以的。而接口就完全不是一回事

抽象类是自底而上抽象出来的，而接口则是自顶向下设计出来的。

要想真正把抽象类和接口用好，还是需要好好用心地去学习设计模式。只有真正把设计模式理解好了，那么你才能算是真正会合理应用抽象类和接口了。

数组优点，比如说数组在内存中连续存储，因此可以快速而容易地从头到尾遍历元素，可以快速修改元素等等。缺点嘛，应该是创建时必须要指定数组变量的大小，还有在两个元素之间添加元素也比较困难。

.NET Framework提供了用于数据存储和检索的专用类，这些类统称集合。这些类提供对堆栈、队列、列表和哈希表的支持。大多数集合类实现相同的接口。

ArrayList是命名空间System.Collections下的一部分，它是使用大小可按需动态增加的数组实现IList接口[MSDN]。

ArrayList的容量是ArrayList可以保存的元素数。ArrayList的默认初始容量为0。随着元素添加到ArrayList中，容量会根据需要通过重新分配自动增加。使用整数索引可以访问此集合中的元素。此集合中的索引从零开始。[MSDN]

ArrayList不是类型安全的。

装箱就是把值类型打包到Object引用类型的一个实例中。

拆箱就是指从对象中提取值类型。

相对于简单的赋值而言，装箱和拆箱过程需要进行大量的计算。对值类型进行装箱时，必须分配并构造一个全新的对象。其次，拆箱所需的强制转换也需要进行大量的计算[MSDN]。

泛型是具有占位符（类型参数）的类、结构、接口和方法，这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。泛型集合类可以将类型参数用作它所存储的对象的类型的占位符；类型参数作为其字段的类型和其方法的参数类型出现[MSDN]。

巨人也有会走弯路的时候，何况我们常人。

通常情况下，都建议使用泛型集合，因为这样可以获得类型安全的直接优点而不需要从基集合类型派生并实现类型特定的成员。此外，如果集合元素为值类型，泛型集合类型的性能通常优于对应的非泛型集合类型（并优于从非泛型基集合类型派生的类型），因为使用泛型时不必对元素进行装箱[MSDN]。

委托是对函数的封装，可以当作给方法的特征指定一个名称。而事件则是委托的一种特殊形式，当发生有意义的事情时，事件对象处理通知过程[PC#]。

事件其实就是设计模式中观察者模式在.NET中的一种实现方式。

委托是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为[MSDN]。委托对象用关键字delegate来声明。而事件是说在发生其他类或对象关注的事情时，类或对象可通过事件通知它们[MSDN]。事件对象用event关键字声明。

EventArgs 是包含事件数据的类的基类[MSDN]。换句话说，这个类的作用就是用来在事件触发时传递数据用的。

学无止境，你需要不断地练习实践才可能真正成为优秀的软件工程师。
